local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

local MAX_TOTAL_OFFSET = 11
local BASE_Y_OFFSET = 2.5
local MAX_X_OFFSET = 6
local MAX_Z_OFFSET = 6
local MAX_Y_UP_OFFSET = 8
local MAX_Y_DOWN_OFFSET = 0
local OBSTACLE_CHECK_RADIUS = 3
local TERRAIN_ADAPTATION_FACTOR = 1.5

local modelOffsets = {}

local function safeSetupModel(model)
    pcall(function()
        if not model or not model.Parent then return end
        
        local head = model:FindFirstChild("Head") or model:FindFirstChild("head")
        local humanoidRootPart = model:FindFirstChild("HumanoidRootPart")
        
        if not head or not humanoidRootPart then return end

        modelOffsets[model] = {
            X = 0,
            Y = BASE_Y_OFFSET,
            Z = 0,
            LastUpdate = os.time(),
            ObstacleAvoidance = Vector3.new(0, 0, 0),
            LastVisiblePosition = humanoidRootPart.CFrame * CFrame.new(0, BASE_Y_OFFSET, 0)
        }

        if model:GetAttribute("HeadTrackingEnabled") then
            local oldConnection = head:GetAttribute("TrackingConnection")
            if oldConnection then
                oldConnection:Disconnect()
            end
        end

        for _, constraint in ipairs(head:GetDescendants()) do
            if constraint:IsA("WeldConstraint") or constraint:IsA("Weld") then
                constraint:Destroy()
            end
        end
        
        head.Anchored = true
        model:SetAttribute("HeadTrackingEnabled", true)

        local connection
        connection = RunService.Heartbeat:Connect(function()
            if not model.Parent or not head or not humanoidRootPart then
                connection:Disconnect()
                modelOffsets[model] = nil
                return
            end

            local offsets = modelOffsets[model]
            if not offsets then return end

            local newCFrame = humanoidRootPart.CFrame * CFrame.new(offsets.X, offsets.Y, offsets.Z)
            head.CFrame = newCFrame
        end)
        
        head:SetAttribute("TrackingConnection", connection)

        model.AncestryChanged:Connect(function()
            if not model.Parent then
                modelOffsets[model] = nil
                if connection then
                    connection:Disconnect()
                end
            end
        end)
    end)
end

local function getTerrainHeightBetween(cameraPos, headPos)
    local steps = 10
    local maxHeight = -math.huge
    
    for i = 0, steps do
        local t = i / steps
        local checkPos = cameraPos:Lerp(headPos, t)
        local rayOrigin = Vector3.new(checkPos.X, 1000, checkPos.Z)
        local rayDirection = Vector3.new(0, -2000, 0)
        
        local raycastParams = RaycastParams.new()
        raycastParams.FilterDescendantsInstances = {Workspace.Terrain}
        raycastParams.FilterType = Enum.RaycastFilterType.Whitelist
        
        local ray = Workspace:Raycast(rayOrigin, rayDirection, raycastParams)
        if ray then
            local terrainHeight = ray.Position.Y
            if terrainHeight > maxHeight then
                maxHeight = terrainHeight
            end
        end
    end
    
    return maxHeight
end

local function findBestHeadPosition(model)
    local head = model:FindFirstChild("Head") or model:FindFirstChild("head")
    local humanoidRootPart = model:FindFirstChild("HumanoidRootPart")
    if not head or not humanoidRootPart then return false end
    
    local camera = Workspace.CurrentCamera
    local cameraPos = camera.CFrame.Position
    local headPos = humanoidRootPart.Position

    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {model, camera}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    
    local directRay = Workspace:Raycast(cameraPos, (headPos - cameraPos).Unit * (headPos - cameraPos).Magnitude, raycastParams)
    if not directRay then
        return true, Vector3.new(0, BASE_Y_OFFSET, 0)
    end

    local maxTerrainHeight = getTerrainHeightBetween(cameraPos, headPos)
    local heightDifference = maxTerrainHeight - headPos.Y

    local dynamicMaxY = MAX_Y_UP_OFFSET
    if heightDifference > 5 then
        dynamicMaxY = math.min(MAX_Y_UP_OFFSET + heightDifference * TERRAIN_ADAPTATION_FACTOR, 20)
    end

    local bestPosition = nil
    local bestScore = -math.huge

    for y = BASE_Y_OFFSET, dynamicMaxY, 1.5 do
        for x = -MAX_X_OFFSET, MAX_X_OFFSET, 1.5 do
            for z = -MAX_Z_OFFSET, MAX_Z_OFFSET, 1.5 do

                if math.abs(x) + math.abs(y - BASE_Y_OFFSET) + math.abs(z) > MAX_TOTAL_OFFSET then
                    continue
                end
                
                local testPos = humanoidRootPart.CFrame * CFrame.new(x, y, z)
                local ray = Workspace:Raycast(cameraPos, (testPos.Position - cameraPos).Unit * (testPos.Position - cameraPos).Magnitude, raycastParams)
                
                if not ray then

                    local distanceScore = 1 / (testPos.Position - headPos).Magnitude
                    local heightScore = y > BASE_Y_OFFSET and 1.2 or 1
                    local totalScore = distanceScore * heightScore
                    
                    if totalScore > bestScore then
                        bestScore = totalScore
                        bestPosition = Vector3.new(x, y, z)
                    end
                end
            end
        end
    end

    if bestPosition and bestPosition.Y > maxTerrainHeight then
        return true, bestPosition
    elseif bestPosition then
        return true, bestPosition
    else

        local offsets = modelOffsets[model]
        if offsets and offsets.LastVisiblePosition then
            local localPos = humanoidRootPart.CFrame:PointToObjectSpace(offsets.LastVisiblePosition.Position)
            return false, Vector3.new(localPos.X, math.max(localPos.Y, BASE_Y_OFFSET), localPos.Z)
        else
            return false, Vector3.new(0, BASE_Y_OFFSET, 0)
        end
    end
end

local function calculateModelOffsets(model)
    local humanoidRootPart = model:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return 0, BASE_Y_OFFSET, 0 end

    local isVisible, bestPosition = findBestHeadPosition(model)
    local offsets = modelOffsets[model] or {X = 0, Y = BASE_Y_OFFSET, Z = 0}
    
    if isVisible then

        offsets.LastVisiblePosition = humanoidRootPart.CFrame * CFrame.new(bestPosition.X, bestPosition.Y, bestPosition.Z)
        return bestPosition.X, bestPosition.Y, bestPosition.Z
    else

        local targetX, targetY, targetZ
        
        if offsets.LastVisiblePosition then
            local localPos = humanoidRootPart.CFrame:PointToObjectSpace(offsets.LastVisiblePosition.Position)
            targetX = localPos.X
            targetY = math.max(localPos.Y, BASE_Y_OFFSET)
            targetZ = localPos.Z
        else
            targetX = 0
            targetY = BASE_Y_OFFSET
            targetZ = 0
        end

        local randomFactorX = math.random() * 0.5 - 0.25
        local randomFactorZ = math.random() * 0.5 - 0.25

        local newX = math.clamp(offsets.X + (targetX - offsets.X) * 0.1 + randomFactorX, -MAX_X_OFFSET, MAX_X_OFFSET)
        local newZ = math.clamp(offsets.Z + (targetZ - offsets.Z) * 0.1 + randomFactorZ, -MAX_Z_OFFSET, MAX_Z_OFFSET)
        local newY = math.clamp(offsets.Y + (targetY - offsets.Y) * 0.2, BASE_Y_OFFSET, MAX_Y_UP_OFFSET) -- Только вверх

        local totalOffset = math.abs(newX) + math.abs(newY - BASE_Y_OFFSET) + math.abs(newZ)
        if totalOffset > MAX_TOTAL_OFFSET then
            local scale = MAX_TOTAL_OFFSET / totalOffset
            newX = newX * scale
            newZ = newZ * scale
            newY = BASE_Y_OFFSET + (newY - BASE_Y_OFFSET) * scale
        end
        
        return newX, newY, newZ
    end
end

local function updateAllModelsOffsets()
    while true do
        task.wait(0.15)
        

        for model, offsets in pairs(modelOffsets) do
            if model.Parent then

                local newX, newY, newZ = calculateModelOffsets(model)
                

                offsets.X = offsets.X + (newX - offsets.X) * 0.2
                offsets.Y = offsets.Y + (newY - offsets.Y) * 0.25
                offsets.Z = offsets.Z + (newZ - offsets.Z) * 0.2
                
                offsets.LastUpdate = os.time()
            else

                modelOffsets[model] = nil
            end
        end
    end
end

local function processCharactersFolder()
    local charactersFolder = Workspace:WaitForChild("Characters")

    for _, model in ipairs(charactersFolder:GetChildren()) do
        if model:IsA("Model") then
            safeSetupModel(model)
        end
    end

    charactersFolder.ChildAdded:Connect(function(model)
        if model:IsA("Model") then
            task.wait(0.5)
            safeSetupModel(model)
            
            if not (model:FindFirstChild("Head") or model:FindFirstChild("head")) then
                local headConnection
                headConnection = model.ChildAdded:Connect(function(child)
                    if child.Name == "Head" or child.Name == "head" then
                        task.wait(0.1)
                        safeSetupModel(model)
                        headConnection:Disconnect()
                    end
                end)
            end
        end
    end)

    while true do
        task.wait(5)
        
        for _, model in ipairs(charactersFolder:GetChildren()) do
            if model:IsA("Model") then
                local head = model:FindFirstChild("Head") or model:FindFirstChild("head")
                local humanoidRootPart = model:FindFirstChild("HumanoidRootPart")
                
                if head and humanoidRootPart and not modelOffsets[model] then
                    safeSetupModel(model)
                end
            end
        end
    end
end

task.spawn(processCharactersFolder)
task.spawn(updateAllModelsOffsets)
